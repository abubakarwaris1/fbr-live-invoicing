name: Deploy Application

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests (if any)
      run: npm test --if-present

    - name: Build client
      run: npm run build:client

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.STATIC_IP }} >> ~/.ssh/known_hosts

    - name: Test SSH connection
      run: |
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@${{ secrets.STATIC_IP }} "echo 'SSH connection successful'"

    - name: Copy files to server
      run: |
        # Create tmp directory if it doesn't exist
        mkdir -p /tmp
        
        # Create tar file
        tar -czf /tmp/fbr-live-invoicing.tar.gz --exclude='.git' --exclude='node_modules' --exclude='.env' --exclude='terraform/.terraform' --exclude='terraform/terraform.tfstate*' .
        
        # Copy to server
        scp -o ConnectTimeout=30 -o StrictHostKeyChecking=no /tmp/fbr-live-invoicing.tar.gz root@${{ secrets.STATIC_IP }}:/tmp/
        
        # Extract on server
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@${{ secrets.STATIC_IP }} << 'REMOTE_SCRIPT'
          set -e
          echo "ðŸš€ Starting deployment with nginx inside container..."
          
          # Create application directory
          mkdir -p /opt/fbr-live-invoicing
          cd /opt/fbr-live-invoicing
          
          # Stop and remove existing containers
          echo "ðŸ›‘ Stopping and removing existing containers..."
          docker-compose down || true
          docker stop fbr-live-invoicing || true
          docker rm -f fbr-live-invoicing || true
          
          # Remove old images to save space
          echo "ðŸ§¹ Cleaning up old images..."
          docker rmi fbr-live-invoicing:latest || true
          docker system prune -f || true
          
          # Extract application files
          echo "ðŸ“ Extracting application files..."
          rm -rf /opt/fbr-live-invoicing/*
          tar -xzf /tmp/fbr-live-invoicing.tar.gz -C /opt/fbr-live-invoicing/
          rm -f /tmp/fbr-live-invoicing.tar.gz
          
          # Create .env file with secrets
          echo "ðŸ“ Creating environment file..."
          cat > /opt/fbr-live-invoicing/.env << EOL
          NODE_ENV=production
          PORT=3001
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          FBR_ACCESS_TOKEN=${{ secrets.FBR_ACCESS_TOKEN }}
          STATIC_IP=${{ secrets.STATIC_IP }}
          EOL
          
          # Build and start the container with nginx inside
          echo "ðŸ”¨ Building and starting container with nginx..."
          cd /opt/fbr-live-invoicing
          docker-compose up -d --build
          
          # Wait for application to start
          echo "â³ Waiting for application to start..."
          sleep 30
          
          # Test health endpoint
          echo "ðŸ” Testing health endpoint..."
          for i in {1..10}; do
            if curl -f http://localhost:3000/health; then
              echo "âœ… Nginx health check passed!"
              break
            else
              echo "âŒ Nginx health check failed, attempt $i/10"
              sleep 5
            fi
          done
          
          # Test API endpoint
          echo "ðŸ” Testing API endpoint..."
          for i in {1..5}; do
            if curl -f http://localhost:3000/api/health; then
              echo "âœ… API health check passed!"
              break
            else
              echo "âŒ API health check failed, attempt $i/5"
              sleep 5
            fi
          done
          
          # Show container status
          echo "ðŸ“Š Container status:"
          docker-compose ps
          
          # Show logs
          echo "ðŸ“‹ Recent logs:"
          docker-compose logs --tail=20
          
          echo "ðŸŽ‰ Deployment completed successfully!"
        REMOTE_SCRIPT

    - name: Comment deployment info
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `ðŸš€ **Application Deployment Successful!**
            
            **Static IP:** ${{ secrets.STATIC_IP }}
            **Web Interface:** http://${{ secrets.STATIC_IP }}:3000
            **API Base URL:** http://${{ secrets.STATIC_IP }}:3000/api
            **Health Check:** http://${{ secrets.STATIC_IP }}:3000/health
            **API Health:** http://${{ secrets.STATIC_IP }}:3000/api/health
            
            **Architecture:** Nginx inside container on port 3000, Express.js backend on port 3001`
          })

  notify:
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "âœ… Application deployment successful!"
          echo "ðŸŒ Web Interface: http://${{ secrets.STATIC_IP }}:3000"
          echo "ðŸ”— API Base URL: http://${{ secrets.STATIC_IP }}:3000/api"
        else
          echo "âŒ Application deployment failed!"
        fi
